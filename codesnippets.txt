This example shows how to select a file using the OpenFileDialog dialog box. OpenFileDialog allows users to select files. It is found in System.Windows.Forms namespace and it displays the standard Windows dialog box.

OpenFileDialog openDialog = new OpenFileDialog();
openDialog.Title = "Select A File";
openDialog.Filter = "Text Files (*.txt)|*.txt" + "|" + 
                    "Image Files (*.png;*.jpg)|*.png;*.jpg" + "|" +
                    "All Files (*.*)|*.*";
if (openDialog.ShowDialog() == DialogResult.OK)
{
    string file = openDialog.FileName;
}

    Quaternion CalcEleGivenAng(float ang, float dis)
    {
        ///<summary>
        /// Given an angle, calculate its position in Unity coordinates
        ///</summary>
        Quaternion pos = Quaternion.AngleAxis(Camera.main.transform.eulerAngles.y + ang, Vector3.up);
        Debug.Log("Elevation as quaternion: " + pos.eulerAngles);
        return pos;

    }

    Quaternion CalcAziGivenAng(float ang, float dis)
    {
        ///<summary>
        /// Given an angle, calculate its position in Unity coordinates
        ///</summary>

        Quaternion pos = Quaternion.AngleAxis(Camera.main.transform.eulerAngles.x + ang, Vector3.right);
        Debug.Log("Azimuth as quaternion: " + pos.eulerAngles);
        return pos;

    }
    
        float CalcAzimuth(GameObject go1, GameObject go2)
    {
        ///<summary>
        /// Given two game objects, calculate their azimuth
        /// </summary>

        // get x,z coordinates of objects
        var vec1 = new Vector2(go1.transform.position.x, go1.transform.position.z);
        var vec2 = new Vector2(go2.transform.position.x, go2.transform.position.z);
        // get camera offset along the same axes
        var vecCam = new Vector2
            (Camera.main.transform.position.x, Camera.main.transform.position.z);
        // calc angle, removing offset from camera
        return Vector2.SignedAngle(vec1 - vecCam, vec2 - vecCam);

    }

    float CalcElevation(GameObject go1, GameObject go2)
    {
        ///<summary>
        /// Given two game objects, calculate their elevation
        /// </summary>

        // get x,y coordinates of objects
        var vec1 = new Vector2(go1.transform.position.z, go1.transform.position.y);
        var vec2 = new Vector2(go2.transform.position.z, go2.transform.position.y);
        var vecCam = new Vector2
            (Camera.main.transform.position.x, Camera.main.transform.position.y);
        // calc angle, removing offset from camera
        return Vector2.SignedAngle(vec2 - vecCam, vec1 - vecCam);

    }
    
        float RandVal(float max, float min)
    {
        ///<summary>
        /// Calculate random float given range max and min
        ///</summary>

        System.Random random = new System.Random();
        double val = (random.NextDouble() * (max - min) + min);
        return (float)val;
    }
    
        void InstantiateStimuli(string val1, string val2)
    {
        ///<summary>
        /// Instantiates the stimuli object from model mdl and with random x
        /// and y values for position (left/right, up/down)
        /// </summary>
        /// 

        // Range of azimuth and elevation values
        //var val1 = CalcAziGivenAng(float.Parse(azi), 0.8f);
        //var val2 = CalcEleGivenAng(float.Parse(ele), 0.8f);
        
        stimObj = (GameObject)Instantiate(mdl,
           CalcPosGivenAziEle(float.Parse(val1), float.Parse(val2), 0.8f), Quaternion.identity);
        //Debug.Log("Distance: " + Vector3.Distance(refObj.transform.position, stimObj.transform.position));

var bounds: Bounds;

// You could also declare these as an array, but they aren't generally
// used in a loop so it usually won't make much difference.
var topFrontLeft: Vector3;
var topFrontRight: Vector3;
var topBackLeft: Vector3;
var topBackRight: Vector3;
var bottomFrontLeft: Vector3;
var bottomFrontRight: Vector3;
var bottomBackLeft: Vector3;
var bottomBackRight: Vector3;


function Start() {
	var mf: MeshFilter = GetComponent(MeshFilter);
	bounds = mf.mesh.bounds;
	corners = new Vector3[8];
}

function UpdateCorners() {
	topFrontRight = transform.TransformPoint(bounds.center + bounds.extents);
	topFrontLeft = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(-1, 1, 1)));
	topBackRight = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(1, 1, -1)));
	topBackLeft = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(-1, 1, -1)));
	bottomFrontRight = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(1, -1, 1)));
	bottomFrontLeft = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(-1, -1, 1)));
	bottomBackRight = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(1, -1, -1)));
	bottomBackLeft = transform.TransformPoint(bounds.center + Vector3.Scale(bounds.extents, Vector3(-1, -1, -1)));
}

function Update () {
	UpdateCorners();
	Debug.DrawLine(topFrontLeft, topFrontRight);
	Debug.DrawLine(bottomFrontLeft, bottomFrontRight);
	Debug.DrawLine(topBackLeft, topBackRight);
	Debug.DrawLine(bottomBackLeft, bottomBackRight);
	Debug.DrawLine(topFrontLeft, topBackLeft);
	Debug.DrawLine(topFrontRight, topBackRight);
	Debug.DrawLine(bottomFrontLeft, bottomBackLeft);
	Debug.DrawLine(bottomFrontRight, bottomBackRight);
	Debug.DrawLine(topFrontLeft, bottomFrontLeft);
	Debug.DrawLine(topFrontRight, bottomFrontRight);
	Debug.DrawLine(topBackLeft, bottomBackLeft);
	Debug.DrawLine(topBackRight, bottomBackRight);
}